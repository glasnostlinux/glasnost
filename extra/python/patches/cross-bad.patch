--- Makefile.pre.in.orig	2021-01-20 20:50:35.644000000 +0000
+++ Makefile.pre.in	2021-01-20 20:52:29.860000000 +0000
@@ -1673,11 +1673,12 @@
 # Install the dynamically loadable modules
 # This goes into $(exec_prefix)
 sharedinstall: sharedmods
+	CC='$(CC)' LDSHARED='$(BLDSHARED)' OPT='$(OPT)' \
 	$(RUNSHARED) $(PYTHON_FOR_BUILD) $(srcdir)/setup.py install \
-	   	--prefix=$(prefix) \
-		--install-scripts=$(BINDIR) \
-		--install-platlib=$(DESTSHARED) \
-		--root=$(DESTDIR)/
+		--prefix=$(prefix) \
+		--install-scripts=$(DESTDIR)$(BINDIR) \
+		--install-platlib=$(DESTDIR)$(DESTSHARED) \
+		--root=/
 	-rm $(DESTDIR)$(DESTSHARED)/_sysconfigdata_$(ABIFLAGS)_$(MACHDEP)_$(MULTIARCH).py
 	-rm -r $(DESTDIR)$(DESTSHARED)/__pycache__
 
--- a/Include/pyport.h.orig
+++ a/Include/pyport.h
@@ -732,14 +732,14 @@
 #define LONG_BIT (8 * SIZEOF_LONG)
 #endif
 
-#if LONG_BIT != 8 * SIZEOF_LONG
+//#if LONG_BIT != 8 * SIZEOF_LONG
 /* 04-Oct-2000 LONG_BIT is apparently (mis)defined as 64 on some recent
  * 32-bit platforms using gcc.  We try to catch that here at compile-time
  * rather than waiting for integer multiplication to trigger bogus
  * overflows.
  */
-#error "LONG_BIT definition appears wrong for platform (bad gcc/glibc config?)."
-#endif
+//#error "LONG_BIT definition appears wrong for platform (bad gcc/glibc config?)."
+//#endif
 
 #ifdef __cplusplus
 }
